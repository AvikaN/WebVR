 <script src="https://aframe.io/releases/0.2.0/aframe.min.js"></script>
 <html> 
  <body>
    <script> 
    //birding code from http://threejs.org/examples/canvas_geometry_birds.html
    //and Daniel Shiffman Nature of Code
    //remove points geometry and add in point lights 
    var intensity = 10;
    var distance = 1000;
    var decay = 2.0;
    var maxSize = 600;
    var minSize = -600;
    var colors = []; 
    var numBoids = 10; 
    var sphere = new THREE.SphereGeometry(0.50, 16, 8);
    var color = 0x0040ff; 

    function random(min, max){
      return Math.random() * (max - min) + min;
    }

    function distance(x1,y1,x2,y2){
      return Math.sqrt((x1 - x2) * (x1 - x2) + (y1-y2) * (y1-y2));
    }

   
    // for(var i = 0; i < numBoids; i++){
    //   colors[i] = new THREE.Color(0xFFFFFF);
    // }

    // //make predator black
    // colors[i] = new THREE.Color(0x000000);

    // //temp 
    // var geometry = new THREE.Geometry();
    // geometry.colors = colors

    // var sprite = new THREE.TextureLoader().load("data/point3.png");
    // //all the points have the samem material 
    // var material = new THREE.PointsMaterial({vertexColors: THREE.VertexColors ,size: 2, map: sprite,alphaTest: 0.5, transparent: true});

    var boids = [];

    AFRAME.registerComponent('boid', {
    schema  : {
        position: {
          type: 'vec3', 
          default: {x: 0, y: 0 , z: -200}
        }
      }, 

      init: function(){
          var pos = this.data.position; 
          this.maxspeed = 1.35;  
          this.loc = new THREE.Vector3(pos.x, pos.y, pos.z); 
          // geometry.vertices.push(this.loc); //collect the vertices inside geometry 
          this.vel = new THREE.Vector3(random(-this.maxspeed,this.maxspeed) , random(-this.maxspeed,this.maxspeed) , 
            random(-this.maxspeed,this.maxspeed));
          this.acc = new THREE.Vector3(0,0,0);
          this.ali = new THREE.Vector3(0,0,0);
          this.coh = new THREE.Vector3(0,0,0);
          this.center = new THREE.Vector3(0,0,0);
          this.wallVector = new THREE.Vector3(0,0,0);
          this.neighbor = 50;  
          this.maxforce = 0.070;
          this.seekforce = 0.035;

          //have each boid be a point light 
          this.light = new THREE.PointLight(color, intensity, distance, decay);
          this.light.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({color: color})));
          this.el.setObject3D('mesh', this.light);
          console.log(this.light.position);
      }, 

      alignment: function(){
        var sum = new THREE.Vector3(0,0,0);
        var count = 0; 
        for(var i = 0; i < boids.length; i++){
          if(Math.random() > 0.6) continue; 
          var bs = boids[i];
          var d = this.loc.distanceTo(bs.components.boid.loc);
          if( d > 0 && d <= this.neighbor){
            sum.add(bs.components.boid.vel);
            count++; 
          }
        }
        if(count > 0)
        {
          sum.divideScalar(count);
          var l = sum.length();
          if( l > this.maxforce){
             sum.divideScalar(l / this.maxforce);
          }
        }
        this.acc.add(sum); 
      },

      cohesion: function(){
        var posSum = new THREE.Vector3(0,0,0);
        var steer = new THREE.Vector3(0,0,0);
        var count = 0; 
        for(var i = 0 ; i < boids.length; i++){
          if (Math.random() > 0.8) continue;
          var bs = boids[i];
          var bloc = bs.components.boid.loc;
          var d = bloc.distanceTo(this.loc); 
          if( d > 0 && d <= this.neighbor){
            posSum.add(bloc);
            count++; 
          }
        }
        if(count > 0){
          posSum.divideScalar(count);
        }
        steer.subVectors(posSum, this.loc);
        var l = steer.length();
        if (l > this.maxforce){
          steer.divideScalar(l/this.maxforce);
        }
        this.acc.add(steer);
      }, 

      separation: function(){
        var posSum = new THREE.Vector3(0,0,0);
        var repulse = new THREE.Vector3(0,0,0);
        for(var i = 0; i < boids.length; i++){
          //if(Math.random() > 0.2) continue; 
          var bs = boids[i];
          var bloc = bs.components.boid.loc;
          var d = bloc.distanceTo(this.loc);
          if( d > 0 && d <= this.neighbor){
            repulse.subVectors(this.loc, bloc);
            repulse.normalize();
            repulse.divideScalar(d);
            posSum.add(repulse);
          }
        }
        this.acc.add(posSum);
      }, 

      boundary: function(){
        if(this.loc.x > maxSize) { this.loc.x = minSize; }
        if(this.loc.x < minSize) { this.loc.x = maxSize; }
        if(this.loc.y > maxSize) { this.loc.y = minSize; }
        if(this.loc.y < minSize) { this.loc.y = maxSize; }
        if(this.loc.z > maxSize) { this.loc.z = minSize; }
        if(this.loc.z < minSize) { this.loc.z = maxSize; }
      }, 

      repulse: function(target){
          var distance = this.loc.distanceTo(target);

          if(distance < 150){
            var steer = new THREE.Vector3();
            steer.subVectors(this.loc, target);
            steer.multiplyScalar(0.5 / distance);
            this.acc.add(steer);
          }
      }, 

      repulsePredator: function(target){
          var distance = this.loc.distanceTo(target);

          if(distance < 100){
            var steer = new THREE.Vector3();
            steer.subVectors(this.loc, target);
            steer.multiplyScalar(0.5 / distance);
            this.acc.add(steer);
          }
      }, 

      seek: function(target){
          var desired = new THREE.Vector3();
          var steer = new THREE.Vector3();
          desired.subVectors(target, this.loc);
          steer.subVectors(desired, this.vel); 
          var l = steer.length();
          if( l > this.seekforce){
             steer.divideScalar(l / this.seekforce);
          }
          this.acc.add(steer);
      }, 

      avoid: function(target){
          var steer = new THREE.Vector3();
          steer.copy(this.loc);
          steer.sub( target );
          steer.multiplyScalar( 1 / this.loc.distanceToSquared( target ) );
          return steer;
      },

      avoidwalls: function(){
          this.wallVector.set(minSize , this.loc.y, this.loc.z);
          this.wallVector = this.avoid( this.wallVector );
          this.wallVector.multiplyScalar(5);
          this.acc.add(this.wallVector);

          this.wallVector.set(maxSize , this.loc.y, this.loc.z);
          this.wallVector = this.avoid( this.wallVector );
          this.wallVector.multiplyScalar(5);
          this.acc.add(this.wallVector);

          this.wallVector.set(this.loc.x , minSize, this.loc.z);
          this.wallVector = this.avoid( this.wallVector );
          this.wallVector.multiplyScalar(5);
          this.acc.add(this.wallVector);

          this.wallVector.set(this.loc.x , maxSize, this.loc.z);
          this.wallVector = this.avoid( this.wallVector );
          this.wallVector.multiplyScalar(5);
          this.acc.add(this.wallVector);

          this.wallVector.set(this.loc.x , this.loc.y , minSize);
          this.wallVector = this.avoid( this.wallVector );
          this.wallVector.multiplyScalar(5);
          this.acc.add(this.wallVector);

          this.wallVector.set(this.loc.x , this.loc.y , maxSize);
          this.wallVector = this.avoid( this.wallVector );
          this.wallVector.multiplyScalar(5);
          this.acc.add(this.wallVector);
      }, 

      move: function(){
        this.vel.add(this.acc);
        var len = this.vel.length();
        if (len > this.maxspeed){
          this.vel.divideScalar( len / this.maxspeed);  
        }
        this.loc.add(this.vel);
        this.light.position.set(this.loc.x, this.loc.y, this.loc.z);
        console.log(this.light.position);
        this.acc.set(0,0,0);
      },

      flock: function(camera){
        this.seek(camera);
        //this.repulsePredator(predator);
        this.alignment();
        this.cohesion();
        this.separation();
        this.repulse(this.center);
      },

      run: function(target){
        this.avoidwalls();
        if(Math.random() > 0.60){
          this.flock(target);
        }
        this.move();
      }
    });

    //you're using AFRame components 
    AFRAME.registerComponent('flock', {
      init: function(){
        this.count = 0; 
        this.numBoids = numBoids;
        for(var i = 0; i < this.numBoids; i++){
            var newb = document.createElement("a-entity");
                  newb.setAttribute("boid");
                  newb.setAttribute("class", "boid");
                  this.el.sceneEl.appendChild(newb);  
                  boids.push(newb);
        }

        // this.predator = document.createElement("a-entity"); 
        // this.predator.setAttribute("predator");
        // this.predator.setAttribute("class", "predator");
        // this.el.sceneEl.appendChild(this.predator);

        //var birds = new THREE.Points(geometry, material);
        //this.el.setObject3D('particle', birds);

      }, 

      tick: function(){
          //geometry.verticesNeedUpdate = true;
          var cam = document.querySelector("#main-cam").components.camera.camera; 
          var direction = cam.getWorldDirection();
          direction.multiplyScalar(350);

          // var p = this.predator.components.predator;
          // p.run();

          for(var i = 0; i < this.numBoids; i++){
              var b = boids[i].components.boid;
              b.run(direction);
          }
      }

    });

    //add  a predator
    //have the movers separate from the predator
    AFRAME.registerComponent('predator', {
        schema:{
          position: {
            type: 'vec3', 
            default: {x: 0, y: 0 , z: -200}
          }
        }, 

        init: function(){ 
          var pos = this.data.position; 
          this.maxspeed = 2;  
          this.loc = new THREE.Vector3(pos.x, pos.y, pos.z); 
          //geometry.vertices.push(this.loc); //collect the vertices inside geometry 
          this.vel = new THREE.Vector3(random(-this.maxspeed,this.maxspeed) , random(-this.maxspeed,this.maxspeed) , 
            random(-this.maxspeed,this.maxspeed));
          this.acc = new THREE.Vector3(0,0,0);
          this.neighbor = 50;  
          this.seekforce = 0.1; 
        }, 

        move: function(){
          this.vel.add(this.acc);
          var len = this.vel.length();
          if (len > this.maxspeed){
            this.vel.divideScalar( len / this.maxspeed);  
          }
          this.loc.add(this.vel);
          this.acc.set(0,0,0);
        },

        run: function(){
          if(Math.random() > 0.60){
            this.seek();
          }
          this.move();
        },

        seek: function(){
          var target = new THREE.Vector3(); 

          for(var i = 0; i < boids.length; i++){
              var b = boids[i].components.boid;
              target.add(b.loc);
          }

          if(boids.length > 0){
            target.divideScalar(boids.length);
          }

          var desired = new THREE.Vector3();
          var steer = new THREE.Vector3();
          desired.subVectors(target, this.loc);
          steer.subVectors(desired, this.vel); 
          var l = steer.length();
          if( l > this.seekforce){
             steer.divideScalar(l / this.seekforce);
          }
          this.acc.add(steer);
        }
    });

    AFRAME.registerComponent('background', {
        init: function(){
            var loader = new THREE.ObjectLoader();
            var scene = document.querySelector("#scene").object3D;
            loader.load( 'js/scene.js', function (object){
                scene.add(object);
            }); 
        }
    }); 
    </script> 
    <a-scene id="scene">
      <a-sky color="#000000"> </a-sky>
      <a-entity background> </a-entity>  
      <a-entity flock> </a-entity>
      <a-camera id="main-cam" position="0 0 0"> 
      </a-camera> 
    </a-scene>
  </body> 
 </html> 