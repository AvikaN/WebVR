 <script src="https://aframe.io/releases/0.2.0/aframe.min.js"></script>
 <script src="perlin.js"></script> 

 <script>
    //tick moves too fast 
    var radius = 500; 
    var noiseScale = 0.001;
    var maxVel = Math.PI / 100;
    noise.seed(Math.random());
    var MAX_POINTS = 100; 

    var offset1 = new THREE.Vector3(Math.random() * 100000, Math.random() * 10000, Math.random() * 10000);
    var offset2 = new THREE.Vector3(Math.random() * 100000, Math.random() * 10000, Math.random() * 10000);

    AFRAME.registerComponent('particle', {

      init: function(){
          this.three_vectors = [];
          this.a = Math.random() * (Math.PI * 2);
          this.b = Math.random() * (Math.PI * 2);
          this.drawCount = 0; 

          var geometry = new THREE.BufferGeometry();
          var positions = new Float32Array(MAX_POINTS * 3); 
          geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
          var material = new THREE.LineBasicMaterial({color: 0xFFFFFF, linewidth: 1});
          this.line = new THREE.Line(geometry, material); 

          //add line to element
          this.el.setObject3D('mesh', new THREE.Line(geometry, material));

          var storePos = []
          storePos.push(this.getCoordinates());
          //set the postions from the start, this makes the rendering much more efficient  
          for (var i = 0; i < MAX_POINTS; i++) {
              var v3 = storePos[storePos.length - 1];
              var noise1 = noise.perlin3(offset1.x + v3.x * noiseScale, offset1.y + v3.y * noiseScale, offset1.z + v3.z * noiseScale); 
              var noise2 = noise.perlin3(offset2.x + v3.x * noiseScale, offset2.y + v3.y * noiseScale, offset2.z + v3.z * noiseScale);
              this.a += map_range(noise1, 0, 1, -maxVel, maxVel);
              this.b += map_range(noise2, 0, 1, -maxVel, maxVel);
              storePos.push(this.getCoordinates()); 
          }
          var pos = this.line.geometry.attributes.position.array;
          var index = 0;

          for ( var i = 0; i < MAX_POINTS; i++) {
              positions[ index ++ ] = storePos[i].x;
              positions[ index ++ ] = storePos[i].y;
              positions[ index ++ ] = storePos[i].z;
          }
      },

      tick: function(){
          if(this.drawCount < MAX_POINTS){
            this.drawCount++;
            this.line.geometry.setDrawRange(0, this.drawCount);
          }
      },

      getCoordinates: function(){
         var x = radius * Math.sin(this.a) * Math.cos(this.b);
         var y = radius * Math.sin(this.a) * Math.sin(this.b);
         var z = radius * Math.cos(this.a);
         return {'x':x, 'y':y, 'z':z}
      } ,

      remove: function () {
        //remove all the objects? 
        this.el.removeObject3D('mesh');
      }

    })

    AFRAME.registerComponent('sphereOfAwesomeness', {

      init: function(){
        //store particle entities
        this.particles = [];
        this.count = 0; 
      }, 

      //consider calling tick for only 100 times 
      tick: function() {
          if(this.particles.length < 50){
            var newp = document.createElement("a-entity");
            newp.setAttribute("particle");
            this.el.sceneEl.appendChild(newp); 
            this.particles.push(newp);
          }
      }
      
    });

    function map_range(value, low1, high1, low2, high2) {
      return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
    } 

 </script>  

    <a-scene>
        <a-sky color="#AAA"> </a-sky> 
        <a-entity sphereOfAwesomeness></a-entity>

        <a-entity position="0 0 0">
            <a-camera></a-camera>
        </a-entity>
    </a-scene>

