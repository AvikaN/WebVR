 <script src="https://aframe.io/releases/0.2.0/aframe.min.js"></script>
 <html> 
  <body>
    <script> 
    //birding code from http://threejs.org/examples/canvas_geometry_birds.html
    //and Daniel Shiffman Nature of Code

    var intensity = 12;
    var distance = 700;
    var decay = 0.25; //.25

    var maxSize = 600;
    var minSize = -600;
    var numBoids = 12; 
    var count = 0; 

    var extrudeSettings = { amount: 1, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
    var s = 0.035; 

    var points = [];
    var leftToppts = [new THREE.Vector2 (-100 , 75) , new THREE.Vector2 (-120 , 0), new THREE.Vector2 (0, 0)];
    points.push(leftToppts);
    var leftBotpots = [new THREE.Vector2 (-120 , -30), new THREE.Vector2 (-90 , -110), new THREE.Vector2 (0, 0)];
    points.push(leftBotpots);
    var shapes = [];
    for(var i = 0; i < points.length; i++){
      var wing = new THREE.Shape();
      wing.moveTo( 0, 0 );
      wing.splineThru(points[i]);
      shapes.push(wing);
    }
    var geometryLeft = new THREE.ExtrudeGeometry(shapes, extrudeSettings );
    var points = [];
    
    var rightToppots = [new THREE.Vector2 (100 , 75), new THREE.Vector2 (120 , 0), new THREE.Vector2 (0, 0)];
    points.push(rightToppots);
    var rightBotpts = [new THREE.Vector2 (120 , -30), new THREE.Vector2 (90 , -110), new THREE.Vector2 (0, 0)];
    points.push(rightBotpts);

    var shapes2 = [];
    for(var i = 0; i < points.length; i++){
        var wing = new THREE.Shape();
        wing.moveTo( 0, 0 );
        wing.splineThru(points[i]);
        shapes2.push(wing);
    }

    colors = [0xf23b71];
    var geometryRight = new THREE.ExtrudeGeometry(shapes2, extrudeSettings );
    var sphere = new THREE.SphereGeometry(0.5,16,8);
    var basicMesh = new THREE.MeshBasicMaterial({color: 0xFFFFFF});

    function random(min, max){
      return Math.random() * (max - min) + min;
    }

    function distance(x1,y1,x2,y2){
      return Math.sqrt((x1 - x2) * (x1 - x2) + (y1-y2) * (y1-y2));
    }

    function map_range(value, low1, high1, low2, high2) {
      return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
    }

    var boids = [];

    AFRAME.registerComponent('boid', {
    schema  : {
        position: {
          type: 'vec3', 
          default: {x: 0, y: 0 , z: -200}
        }
      }, 

      init: function(){
          var pos = this.data.position; 
          this.maxspeed = 1;  
          this.loc = new THREE.Vector3(pos.x, pos.y, pos.z); 
          this.vel = new THREE.Vector3(random(-this.maxspeed,this.maxspeed) , random(-this.maxspeed,this.maxspeed) , 
            random(-this.maxspeed,this.maxspeed));
          this.acc = new THREE.Vector3(0,0,0);
          this.ali = new THREE.Vector3(0,0,0);
          this.coh = new THREE.Vector3(0,0,0);
          this.center = new THREE.Vector3(0,0,0);
          this.wallVector = new THREE.Vector3(0,0,0);
          this.neighbor = 35;  
          this.maxforce = 0.060;
          this.seekforce = 0.020;

          this.light = new THREE.PointLight(0xFFFFFF, intensity, distance, decay);
          this.mesh = new THREE.Mesh(sphere, basicMesh);

          //butterfly 
          this.group = new THREE.Group();

          var c = Math.floor(Math.random() * colors.length);
          var wingMesh  = new THREE.MeshBasicMaterial( { color: colors[c]} );
          this.leftWing = new THREE.Mesh(geometryLeft, wingMesh);
          this.leftWing.scale.set(s,s,s);
          this.group.add(this.leftWing);

          this.rightWing = new THREE.Mesh(geometryRight, wingMesh);
          this.rightWing.scale.set(s,s,s);
          this.group.add(this.rightWing);

          this.light.add(this.mesh);
          this.el.setObject3D('mesh', this.light);
          this.el.setObject3D('butterfly', this.group);

          //base rotation
          this.group.rotation.x = Math.PI / 2;  
          this.zBaseRotation = -Math.PI / 2;
          
          this.rightWing.rotation.y = 0.20;
          this.leftWing.rotation.y = -0.20;

          this.phase = Math.floor( Math.random() * 62.83 );
      }, 

      alignment: function(){
        var sum = new THREE.Vector3(0,0,0);
        var count = 0; 
        for(var i = 0; i < boids.length; i++){
          if(Math.random() > 0.6) continue; 
          var bs = boids[i];
          var d = this.loc.distanceTo(bs.components.boid.loc);
          if( d > 0 && d <= this.neighbor){
            sum.add(bs.components.boid.vel);
            count++; 
          }
        }
        if(count > 0)
        {
          sum.divideScalar(count);
          var l = sum.length();
          if( l > this.maxforce){
             sum.divideScalar(l / this.maxforce);
          }
        }
        this.acc.add(sum); 
      },

      cohesion: function(){
        var posSum = new THREE.Vector3(0,0,0);
        var steer = new THREE.Vector3(0,0,0);
        var count = 0; 
        for(var i = 0 ; i < boids.length; i++){
          if (Math.random() > 0.8) continue;
          var bs = boids[i];
          var bloc = bs.components.boid.loc;
          var d = bloc.distanceTo(this.loc); 
          if( d > 0 && d <= this.neighbor){
            posSum.add(bloc);
            count++; 
          }
        }
        if(count > 0){
          posSum.divideScalar(count);
        }
        steer.subVectors(posSum, this.loc);
        var l = steer.length();
        if (l > this.maxforce){
          steer.divideScalar(l/this.maxforce);
        }
        this.acc.add(steer);
      }, 

      separation: function(){
        var posSum = new THREE.Vector3(0,0,0);
        var repulse = new THREE.Vector3(0,0,0);
        for(var i = 0; i < boids.length; i++){
          //if(Math.random() > 0.2) continue; 
          var bs = boids[i];
          var bloc = bs.components.boid.loc;
          var d = bloc.distanceTo(this.loc);
          if( d > 0 && d <= this.neighbor){
            repulse.subVectors(this.loc, bloc);
            repulse.normalize();
            repulse.divideScalar(d);
            posSum.add(repulse);
          }
        }
        this.acc.add(posSum);
      }, 

      boundary: function(){
        if(this.loc.x > maxSize) { this.loc.x = minSize; }
        if(this.loc.x < minSize) { this.loc.x = maxSize; }
        if(this.loc.y > maxSize) { this.loc.y = minSize; }
        if(this.loc.y < minSize) { this.loc.y = maxSize; }
        if(this.loc.z > maxSize) { this.loc.z = minSize; }
        if(this.loc.z < minSize) { this.loc.z = maxSize; }
      }, 

      repulse: function(target){
          var distance = this.loc.distanceTo(target);

          if(distance < 150){
            var steer = new THREE.Vector3();
            steer.subVectors(this.loc, target);
            steer.multiplyScalar(0.5 / distance);
            this.acc.add(steer);
          }
      }, 

      repulsePredator: function(target){
          var distance = this.loc.distanceTo(target);

          if(distance < 100){
            var steer = new THREE.Vector3();
            steer.subVectors(this.loc, target);
            steer.multiplyScalar(0.5 / distance);
            this.acc.add(steer);
          }
      }, 

      seek: function(target){
          var desired = new THREE.Vector3();
          var steer = new THREE.Vector3();
          desired.subVectors(target, this.loc);
          steer.subVectors(desired, this.vel); 
          var l = steer.length();
          if( l > this.seekforce){
             steer.divideScalar(l / this.seekforce);
          }
          this.acc.add(steer);
      }, 

      avoid: function(target){
          var steer = new THREE.Vector3();
          steer.copy(this.loc);
          steer.sub( target );
          steer.multiplyScalar( 1 / this.loc.distanceToSquared( target ) );
          return steer;
      },

      avoidwalls: function(){
          this.wallVector.set(minSize , this.loc.y, this.loc.z);
          this.wallVector = this.avoid( this.wallVector );
          this.wallVector.multiplyScalar(5);
          this.acc.add(this.wallVector);

          this.wallVector.set(maxSize , this.loc.y, this.loc.z);
          this.wallVector = this.avoid( this.wallVector );
          this.wallVector.multiplyScalar(5);
          this.acc.add(this.wallVector);

          this.wallVector.set(this.loc.x , minSize, this.loc.z);
          this.wallVector = this.avoid( this.wallVector );
          this.wallVector.multiplyScalar(5);
          this.acc.add(this.wallVector);

          this.wallVector.set(this.loc.x , maxSize, this.loc.z);
          this.wallVector = this.avoid( this.wallVector );
          this.wallVector.multiplyScalar(5);
          this.acc.add(this.wallVector);

          this.wallVector.set(this.loc.x , this.loc.y , minSize);
          this.wallVector = this.avoid( this.wallVector );
          this.wallVector.multiplyScalar(5);
          this.acc.add(this.wallVector);

          this.wallVector.set(this.loc.x , this.loc.y , maxSize);
          this.wallVector = this.avoid( this.wallVector );
          this.wallVector.multiplyScalar(5);
          this.acc.add(this.wallVector);
      }, 

      move: function(){
        this.vel.add(this.acc);
        var len = this.vel.length();
        if (len > this.maxspeed){
          this.vel.divideScalar( len / this.maxspeed);  
        }
        this.loc.add(this.vel);
        var cX = map_range(this.loc.x, minSize, maxSize, 0 , 1);
        var cY = map_range(this.loc.y, minSize, maxSize, 0 , 1);
        var cZ = map_range(this.loc.z, minSize, maxSize, 0 , 1);
        this.light.position.set(this.loc.x, this.loc.y, this.loc.z);
        this.light.color.setRGB(cX, cY, cZ);
        this.group.position.copy(this.light.position);

        this.group.rotation.z = (Math.atan2( -this.vel.z, this.vel.x ) + this.zBaseRotation) / 12; 
        this.rightWing.rotation.x = -Math.asin( this.vel.y / this.vel.length()) / 4;
        this.leftWing.rotation.x = -Math.asin( this.vel.y / this.vel.length()) / 4;
        this.phase = ( this.phase + ( Math.max( 0, this.leftWing.rotation.x / 8) + 0.08 )) %  50 ;
        this.rightWing.rotation.y = Math.sin( this.phase );
        this.leftWing.rotation.y = -Math.sin( this.phase );
        this.acc.set(0,0,0);
      },

      flock: function(camera, predator){
        this.seek(camera);
       // this.repulsePredator(predator);
        this.alignment();
        this.cohesion();
        this.separation();
        this.repulse(this.center);
      },

      run: function(target, predator){
        this.avoidwalls();
        if(Math.random() > 0.60){
          this.flock(target, predator);
        }
        this.move();
      }
    });

    //you're using AFRame components 
    AFRAME.registerComponent('flock', {
      init: function(){
        this.count = 0; 
        this.numBoids = numBoids;
        for(var i = 0; i < this.numBoids; i++){
            var newb = document.createElement("a-entity");
                  newb.setAttribute("boid");
                  newb.setAttribute("class", "boid");
                  this.el.sceneEl.appendChild(newb);  
                  boids.push(newb);
        }

        this.predator = document.createElement("a-entity"); 
        this.predator.setAttribute("predator");
        this.predator.setAttribute("class", "predator");
        this.el.sceneEl.appendChild(this.predator);
      }, 

      tick: function(){
          //geometry.verticesNeedUpdate = true;
          var cam = document.querySelector("#main-cam").components.camera.camera; 
          var direction = cam.getWorldDirection();
          direction.multiplyScalar(500);

          var p = this.predator.components.predator;
          p.run();

          for(var i = 0; i < this.numBoids; i++){
              var b = boids[i].components.boid;
              b.run(direction, p.loc);
          }
      }

    });

    //add  a predator
    //have the movers separate from the predator
    AFRAME.registerComponent('predator', {
        schema:{
          position: {
            type: 'vec3', 
            default: {x: 0, y: 0 , z: -200}
          }
        }, 

        init: function(){ 
          var pos = this.data.position; 
          this.maxspeed = 2;  
          this.loc = new THREE.Vector3(pos.x, pos.y, pos.z); 
          //geometry.vertices.push(this.loc); //collect the vertices inside geometry 
          this.vel = new THREE.Vector3(random(-this.maxspeed,this.maxspeed) , random(-this.maxspeed,this.maxspeed) , 
            random(-this.maxspeed,this.maxspeed));
          this.acc = new THREE.Vector3(0,0,0);
          this.neighbor = 100;  
          this.seekforce = 0.1; 

          // this.light = new THREE.PointLight(predatorColor, 10, 800, decay);
          // this.light.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({color: predatorColor})));
          // this.el.setObject3D('mesh', this.light);
        }, 

        move: function(){
          this.vel.add(this.acc);
          var len = this.vel.length();
          if (len > this.maxspeed){
            this.vel.divideScalar( len / this.maxspeed);  
          }
          this.loc.add(this.vel);
          //this.light.position.set(this.loc.x, this.loc.y, this.loc.z);
          this.acc.set(0,0,0); 
        },

        run: function(){
          if(Math.random() > 0.60){
            this.seek();
          }
          this.move();
        },

        seek: function(){
          var target = new THREE.Vector3(); 

          for(var i = 0; i < boids.length; i++){
              var b = boids[i].components.boid;
              target.add(b.loc);
          }

          if(boids.length > 0){
            target.divideScalar(boids.length);
          }

          var desired = new THREE.Vector3();
          var steer = new THREE.Vector3();
          desired.subVectors(target, this.loc);
          steer.subVectors(desired, this.vel); 
          var l = steer.length();
          if( l > this.seekforce){
             steer.divideScalar(l / this.seekforce);
          }
          this.acc.add(steer);
        }
    });

    AFRAME.registerComponent('background', {
        init: function(){
            var loader = new THREE.ObjectLoader();
            var scene = document.querySelector("#scene").object3D;
            loader.load( 'js/scene.js', function (object){
                scene.add(object);
            }); 
        }
    }); 

    </script> 
    <a-scene id="scene">
      <a-sky color="#000000"> </a-sky>
      <a-entity background> </a-entity>  
      <a-entity flock> </a-entity>
      <a-camera id="main-cam" position="0 0 0"> 
      </a-camera> 
    </a-scene>
  </body> 
 </html> 